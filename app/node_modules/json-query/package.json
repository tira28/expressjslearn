{
  "author": {
    "name": "Matt McKegg",
    "email": "matt@wetsand.co.nz",
    "url": "http://twitter.com/MattMcKegg"
  },
  "name": "json-query",
  "description": "Retrieves values from JSON objects for data binding. Offers params, nested queries, deep queries, custom reduce/filter functions and simple boolean logic. Browserify compatible.",
  "version": "2.1.1",
  "homepage": "http://github.com/mmckegg/json-query",
  "repository": {
    "type": "git",
    "url": "git://github.com/mmckegg/json-query.git"
  },
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js --tap"
  },
  "devDependencies": {
    "ava": "^0.14.0",
    "es5-shim": "~2.1.0",
    "tape": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "keywords": [
    "data binding",
    "filter",
    "json",
    "query"
  ],
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "chrome/20.0",
      "chrome/25.0",
      "chrome/latest",
      "chrome/canary",
      "firefox/3.6",
      "firefox/20.0",
      "firefox/latest",
      "firefox/nightly",
      "opera/12.0",
      "opera/latest",
      "safari/4.0",
      "safari/latest",
      "opera/next",
      "iphone/6.0..latest",
      "ipad/6.0..latest",
      "safari/6.0..latest",
      "android-browser/4.2..latest",
      "iexplore/6.0",
      "iexplore/9.0..latest"
    ]
  },
  "readme": "json-query\n===\n\nRetrieves values from JSON objects for data binding. Offers params, nested queries, deep queries, custom reduce/filter functions and simple boolean logic.\n\n## Install via [npm](https://www.npmjs.com/package/json-query)\n\n```bash\n$ npm install json-query\n```\n\n## API\n\n```js\nvar jsonQuery = require('json-query')\n```\n\n### jsonQuery(query, options)\n\nSpecify a query and what to query - returns an object that describes the result of the query.\n\n```js\n\nvar data = {\n  people: [\n    {name: 'Matt', country: 'NZ'},\n    {name: 'Pete', country: 'AU'},\n    {name: 'Mikey', country: 'NZ'}\n  ]\n}\n\njsonQuery('people[country=NZ].name', {\n  data: data\n}) //=> {value: 'Matt', parents: [...], key: 0} ... etc\n```\n\n#### options:\n\n- **data** or **rootContext**: The main JS object to query.\n- **source** or **context** (optional): The current object we're interested in. Is accessed in query by starting with `.`\n- **parent** (optional): An additional context for looking further up the tree. Is accessed by `..`\n- **locals**: Specify an object containing helper functions. Accessed by ':filterName'. Expects function(input, args...) with `this` set to original passed in options.\n- **globals**: Falls back to globals when no local function found.\n- **force** (optional): Specify an object to be returned from the query if the query fails - it will be saved into the place the query expected the object to be.\n- **allowRegexp** (optional): enable `~` operator. Before enabling regexp match to anyone, consider the [user defined regular expression security concerns](http://stackoverflow.com/questions/20928677/user-defined-regular-expression-security-concerns).\n\n## Queries\n\nQueries are strings that describe an object or value to pluck out, or manipulate from the context object. The syntax is a little bit CSS, a little bit JS, but pretty powerful.\n\n### Accessing properties (dot notation)\n\n`person.name`\n\n### Array accessors\n\n`people[0]`\n\n### Array pluck\n\n`people.name` => return all the names of people\n\n### Get all values of a lookup\n\n`lookup[*]`\n\n### Array filter\n\nBy default **only the first** matching item will be returned:\n\n`people[name=Matt]`\n\nBut if you add an asterisk (`*`), **all** matching items will be returned:\n\n`people[*country=NZ]`\n\nYou can use comparative operators:\n\n`people[*rating>=3]`\n\nOr use boolean logic:\n\n`people[* rating >= 3 & starred = true]`\n\nIf `options.enableRegexp` is enabled, you can use the `~` operator to match `RegExp`:\n\n`people[*name~/^R/i]`\n\nYou can also **negate** any of the above examples by adding a `!` before the `=` or `~`:\n\n`people[*country!=NZ]`\n\n### Or syntax\n\n`person.greetingName|person.name`\n\n### Deep queries\n\nSearch through multiple levels of Objects/Arrays\n\n```js\nvar data = {\n  grouped_people: {\n    'friends': [\n      {name: 'Steve', country: 'NZ'},\n      {name: 'Bob', country: 'US'}\n    ],\n    'enemies': [\n      {name: 'Evil Steve', country: 'AU'}\n    ]\n  }\n}\n\njsonQuery('grouped_people[][country=NZ]', {data: data})\n```\n### Inner queries\n\n```js\nvar data = {\n  page: {\n    id: 'page_1',\n    title: 'Test'\n  },\n  comments_lookup: {\n    'page_1': [\n      {id: 'comment_1', parent_id: 'page_1', content: \"I am a comment\"}\n    ]\n  }\n}\n\n// get the comments that match page's id\njsonQuery('comments_lookup[{page.id}]', {data: data})\n```\n\n### Local functions (helpers)\n\nAllows to to hack the query system to do just about anything.\n\nSome nicely contrived examples:\n\n```js\nvar helpers = {\n  greetingName: function(input){\n    if (input.known_as){\n      return input.known_as\n    } else {\n      return input.name\n    }\n  },\n  and: function(inputA, inputB){\n    return inputA && inputB\n  },\n  text: function(input, text){\n    return text\n  },\n  then: function(input, thenValue, elseValue){\n    if (input){\n      return thenValue\n    } else {\n      return elseValue\n    }\n  }\n}\n\nvar data = {\n  is_fullscreen: true,\n  is_playing: false,\n  user: {\n    name: \"Matthew McKegg\",\n    known_as: \"Matt\"\n  }\n}\n\njsonQuery('user:greetingName', {\n  data: data, locals: helpers\n}).value //=> \"Matt\"\n\njsonQuery(['is_fullscreen:and({is_playing}):then(?, ?)', \"Playing big!\", \"Not so much\"], {\n  data: data, locals: helpers\n}).value //=> \"Not so much\"\n\njsonQuery(':text(This displays text cos we made it so)', {\n  locals: helpers\n}).value //=> \"This displays text cos we made it so\"\n\n```\n\nOr you could add a `select` helper:\n\n```js\njsonQuery('people:select(name, country)', {\n  data: data,\n  locals: {\n    select: function (input) {\n      if (Array.isArray(input)) {\n        var keys = [].slice.call(arguments, 1)\n        return input.map(function (item) {\n          return Object.keys(item).reduce(function (result, key) {\n            if (~keys.indexOf(key)) {\n              result[key] = item[key]\n            }\n            return result\n          }, {})\n        })\n      }\n    }\n  }\n})\n```\n\nYou can also use helper functions inside array filtering:\n\n```js\njsonQuery('people[*:recentlyUpdated]', {\n  data: data,\n  locals: {\n    recentlyUpdated: function (item) {\n      return item.updatedAt < Date.now() - (30 * 24 * 60 * 60 * 1000)\n    }\n  }\n})\n```\n\n### Context\n\nSpecifying context ('data', 'source', and 'parent' options) is good for databinding and working on a specific object and still keeping the big picture available.\n\n```js\nvar data = {\n  styles: {\n    bold: 'font-weight:strong',\n    red: 'color: red'\n  },\n  paragraphs: [\n    {content: \"I am a red paragraph\", style: 'red'},\n    {content: \"I am a bold paragraph\", style: 'bold'},\n  ],\n}\n\nvar pageHtml = ''\ndata.paragraphs.forEach(function(paragraph){\n  var style = jsonQuery('styles[{.style}]', {data: data, source: paragraph}).value\n  var content = jsonQuery('.content', data: data, source: paragraph) // pretty pointless :)\n  pageHtml += \"<p style='\" + style \"'>\" + content + \"</p>\"\n})\n```\n\n## Query Params\n\nParams can be specified by passing in an array with the first param the query (with ? params) and subsequent params.\n\n```js\njsonQuery(['people[country=?]', 'NZ'])\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mmckegg/json-query/issues"
  },
  "dependencies": {},
  "_id": "json-query@2.1.1",
  "dist": {
    "shasum": "904088cbfd6fd63dc2ba8abc78a176bda5777d4d"
  },
  "_from": "json-query@",
  "_resolved": "https://registry.npmjs.org/json-query/-/json-query-2.1.1.tgz"
}
